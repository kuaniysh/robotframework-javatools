* Setting *	* Value *
library	rmilauncher.RmiLauncher	${app}	WITH NAME	myAppLauncher
library	rmilauncher.RmiLauncher	${app}	1sec	WITH NAME	oneSec
library	rmilauncher.RmiLauncher	${app}	10sec	WITH NAME	tenSec
library	rmilauncher.RmiLauncher	${app}	WITH NAME	reused

*Variable*	*Value*
${app}	org.robotframework.jvmconnector.mocks.MyApplication
${remoteLib}	org.robotframework.jvmconnector.keyword.JvmconnectorKeywords
${timeoutMsg}=	Importing ${remoteLib} timed out.

* Test Case *	* Action *	* Argument *
Starts Application And Imports Remote Library
	myAppLauncher.startApplication
	myAppLauncher.importRemoteLibrary	${remoteLib}	WITH NAME	myApp
	remoteLibraryShouldBeImported

Importing Remote Library Times Outs If Application Is Not Started
	shouldFailInApproximatelyOneSecond	${timeoutMsg}	oneSec.importRemoteLibrary	${remoteLib}	WITH NAME	thisShouldFail

Importing Remote Library Times Outs If Application Is Stopped
	tenSec.startApplication
	tenSec.importRemoteLibrary	${remoteLib}	WITH NAME	stoppedApp
	runKeywordAndIgnoreError	stoppedApp.stopJvm
	shouldFailInApproximatelyTenSeconds	${timeoutMsg}	tenSec.importRemoteLibrary	${remoteLib}	WITH NAME	thisShouldFail

Reimports After Restart
	reused.startApplication
	reused.importRemoteLibrary	${remoteLib}	WITH NAME	someApp
	remoteLibraryShouldBeImported	someApp
	runKeywordAndIgnoreError	someApp.stopJvm
	reused.startApplication
	reused.importRemoteLibrary	${remoteLib}	WITH NAME	someApp
	remoteLibraryShouldBeImported	someApp

#TODO: parallel testing:
#- use WITH NAMEs
#- assert JVMs are different?

*Keyword*	*Action*	*Argument*	*Argument*
remoteLibraryShouldBeImported	[arguments]	${library}=myApp
	applicationShouldBeRunning	${library}
	runKeyword	${library}.stopApplication
	applicationShouldNotBeRunning	${library}

applicationShouldBeRunning	[arguments]	${library}=myApp
	${appIsRunning}=	runKeyword	${library}.applicationIsRunning
	shouldBeTrue	${appIsRunning}

applicationShouldNotBeRunning	[arguments]	${library}=myApp
	${appIsRunning}=	runKeyword	${library}.applicationIsRunning
	shouldNotBeTrue	${appIsRunning}

shouldFailInApproximatelyOneSecond	[arguments]	${expectedErrorMsg}	${keyword}	@{arguments}
	shouldFailInApproximatelyTime	1	${expectedErrorMsg}	${keyword}	@{arguments}

shouldFailInApproximatelyTenSeconds	[arguments]	${expectedErrorMsg}	${keyword}	@{arguments}
	shouldFailInApproximatelyTime	10	${expectedErrorMsg}	${keyword}	@{arguments}

shouldFailInApproximatelyTime	[arguments]	${timeout}	${expectedErrorMsg}	${keyword}	@{arguments}
	${startTime}=	getTime	epoch
	runKeywordAndExpectError	${expectedErrorMsg}	${keyword}	@{arguments}
	${endTime}=	getTime	epoch
	${runTime}=	evaluate	${endTime} - ${startTime}
	${stoppedBeforeTimeout}=	evaluate	${runTime} < ${timeout}
	${stoppedWithinTreshold}=	evaluate	${runTime} > ${timeout} - 2
	shouldNotBeTrue	${stoppedBeforeTimeout}
	shouldBeTrue	${stoppedWithinTreshold}
